Here you go — a clean **`.cursorrules.md`** for **Rails 7** + Postgres + Heroku:

````markdown
# Social Catering MVP – Cursor AI Rules

## Project Overview
**Name:** Social Catering MVP  
**Description:** Workforce scheduling tool for Social Catering. 3 admins manage ~25–30 workers. Create/edit shifts, search workers, assign with conflict detection, and maintain audit logs.  
**Timeline:** 21 days (Days 1–9: Backend, Days 10–17: UI, Days 18–21: QA)  
**Budget:** $5,000 fixed price — avoid scope creep.

---

## Tech Stack
- **Backend:** Ruby on Rails **7.x**
- **Frontend:** React 18 + TypeScript
- **Database:** PostgreSQL 14+
- **CSS:** Tailwind CSS v4
- **Auth:** Devise
- **Hosting:** Heroku (Eco/Basic dynos) + Heroku Postgres
- **Monitoring:** Sentry + `/healthz` endpoint

---

## Core Database Rules

### Datetime Conventions
- All datetime columns MUST be named `*_utc` (e.g., `start_time_utc`, `expires_at_utc`, `created_at_utc`).
- Use **TIMESTAMPTZ** in PostgreSQL migrations.
- Always store UTC; convert to local time **in UI only**.
- Never use timezone-naive datetimes.

### Data Types
- Use **JSONB** for flexible columns: `skills_json`, `before_json`, `after_json`.
- Add **tsvector** column(s) for full-text search (e.g., `skills_tsvector`).
- Use **CHECK** constraints for status/enum fields instead of Rails enums:
  ```sql
  CHECK (status IN ('draft', 'published', 'assigned', 'completed'))
````

### Foreign Keys & Deletes

* Specify `on_delete` explicitly:

  * `on_delete: :cascade` for owned children.
  * `on_delete: :restrict` for references.

  ```ruby
  add_foreign_key :assignments, :workers, on_delete: :restrict
  add_foreign_key :assignments, :shifts, on_delete: :cascade
  ```
* **Never hard-delete** historical data. Use `active: false` for workers with history.

---

## Indexing Strategy

* Index **all** foreign keys.
* Compound indexes for common queries:

  ```ruby
  add_index :shifts, [:start_time_utc, :status]
  add_index :shifts, [:start_time_utc, :end_time_utc]
  ```
* GIN indexes for JSONB and tsvector:

  ```ruby
  add_index :workers, :skills_json, using: :gin
  execute "CREATE INDEX idx_workers_search ON workers USING gin(skills_tsvector);"
  ```
* Partial unique index for nullable fields:

  ```ruby
  add_index :workers, :email, unique: true, where: "email IS NOT NULL"
  ```

---

## Search Implementation

### Full-Text Search (Workers)

* **≥ 3 chars:** use tsvector

  ```ruby
  Worker.where("skills_tsvector @@ to_tsquery(?)", "#{query}:*")
  ```
* **< 3 chars:** fallback to ILIKE

  ```ruby
  Worker.where("first_name ILIKE ? OR last_name ILIKE ?", "#{query}%", "#{query}%")
  ```

### Sync tsvector

```ruby
class Worker < ApplicationRecord
  before_save :sync_skills_tsvector

  private

  def sync_skills_tsvector
    skills_array =
      case skills_json
      when String then JSON.parse(skills_json) rescue []
      when Array  then skills_json
      else []
      end

    text = skills_array.compact.map(&:to_s).map(&:strip).reject(&:blank?).uniq.join(" ")
    self.skills_text = text
    self.skills_tsvector = ActiveRecord::Base.sanitize_sql_for_conditions(
      ["to_tsvector('simple', ?)", text]
    )
  end
end
```

---

## Concurrency & Race Conditions

### Advisory Locks (Postgres)

Use advisory locks to serialize per-worker assignments:

```ruby
Assignment.transaction do
  conn = ActiveRecord::Base.connection
  conn.execute("SELECT pg_advisory_lock(#{worker.id})")
  begin
    # Overlap
    conflicts = Assignment.joins(:shift)
      .where(worker_id: worker.id, status: 'assigned')
      .where("shifts.start_time_utc < ? AND shifts.end_time_utc > ?",
             new_shift.end_time_utc, new_shift.start_time_utc)
      .lock("FOR UPDATE")
    raise OverlapError, "Worker has overlapping shift" if conflicts.exists?

    # Capacity
    assigned = Assignment.where(shift_id: new_shift.id, status: 'assigned').count
    raise CapacityError, "Shift is full" if assigned >= new_shift.capacity

    # Cert expiration (if required)
    if new_shift.required_cert_id
      cert_ok = worker.worker_certifications
        .where(cert_id: new_shift.required_cert_id)
        .where("expires_at_utc >= ?", new_shift.end_time_utc)
        .exists?
      raise CertExpiredError, "Certification expired or missing" unless cert_ok
    end

    Assignment.create!(
      shift: new_shift, worker: worker, assigned_by: current_user,
      assigned_at_utc: Time.current, status: 'assigned'
    )
  ensure
    conn.execute("SELECT pg_advisory_unlock(#{worker.id})")
  end
end
```

Return **HTTP 409** for lock timeout to signal a safe retry.

---

## Conflict Detection (3 Hard Rules)

1. **Time Overlap**

   ```ruby
   new.start_time_utc < existing.end_time_utc &&
   new.end_time_utc   > existing.start_time_utc
   ```
2. **Capacity**

   ```ruby
   Assignment.where(shift_id: shift.id, status: 'assigned').count < shift.capacity
   ```
3. **Certification Expiration**

   ```ruby
   worker_cert.expires_at_utc >= shift.end_time_utc
   ```

---

## Code Conventions

### Models

* Explicit `belongs_to/has_many` associations.
* Validations for presence/uniqueness; custom `end_time_after_start_time`.
* Scopes: `scope :active, -> { where(active: true) }`.
* Callbacks: `before_save :sync_skills_tsvector`; `after_* :log_activity`.

**Example associations:**

```ruby
class Worker < ApplicationRecord
  has_many :worker_certifications, dependent: :destroy
  has_many :certifications, through: :worker_certifications
  has_many :assignments, dependent: :restrict_with_error
  has_many :shifts, through: :assignments
end
```

### Controllers

* Keep thin; extract business logic to services.
* `before_action :authenticate_user!` for protected routes.
* Strong params everywhere.
* Rescue and return **clear, user-friendly** JSON.

### Services

* Location: `app/services/`
* Verb-based names: `AssignWorkerToShift`, `CheckShiftConflicts`
* Single `call` method; return `{ success:, data:, error: }`

```ruby
class AssignWorkerToShift
  def initialize(shift:, worker:, assigned_by:)
    @shift, @worker, @assigned_by = shift, worker, assigned_by
  end

  def call
    # transaction + conflict checks + assignment
    { success: true, assignment: assignment }
  rescue => e
    { success: false, error: e.message }
  end
end
```

### API Response Format

```json
// Success
{ "data": { "id": 1, ... }, "status": "success" }
// Error
{ "error": "Worker has overlapping shift", "status": "error" }
// Validation
{ "errors": { "email": ["has already been taken"] }, "status": "validation_error" }
```

---

## Anti-Patterns (Never Do)

* ❌ MySQL syntax (`MATCH`, `AUTO_INCREMENT`, `GET_LOCK`)
* ❌ Timezone-naive datetimes / columns not named `*_utc`
* ❌ Raw SQL with string interpolation
* ❌ `dependent: :delete_all` (use `:destroy` for callbacks)
* ❌ Hard deletes on workers with history
* ❌ Rails enums for persisted statuses (prefer DB CHECK)
* ❌ Logging secrets/tokens
* ❌ N+1 queries (use `includes`/`joins`)

---

## Performance Targets

* Dashboard: **< 2s** with 100+ shifts
* Search: **< 300ms** (p95)
* Assignment API: **< 500ms** (p95)
* Detect N+1 in dev with **bullet** gem.

---

## File Organization

```
app/
├─ controllers/
│  └─ api/v1/
├─ models/
│  └─ concerns/   # Auditable, Searchable
├─ services/
├─ validators/
└─ views/
```

---

## Testing Strategy

**Framework:** Minitest (Rails default)
**Locations:** `test/models`, `test/services`, `test/controllers`

**Must-test:**

* All 3 conflict rules
* Concurrent assignment (advisory lock)
* Search behavior (<3 vs ≥3 chars)
* Activity logging on every write
* Edge cases (nil/empty/boundaries)
* DST edge (create shift on DST transition; stored correctly as UTC)

---

## Security Checklist

* ✅ CSRF protection (Rails default)
* ✅ Strong params in all controllers
* ✅ `authenticate_user!` for protected actions
* ✅ No sensitive data in logs
* ✅ Parameterized queries only
* ✅ Admin-only access for MVP
* ✅ SSL enforced (Heroku)
* ✅ Secrets via env vars (no secrets in git)

---

## Deployment (Heroku)

### Env Vars (Required)

```bash
DATABASE_URL=postgres://...   # Heroku sets automatically
SECRET_KEY_BASE=...           # rails secret
RAILS_ENV=production
RAILS_MASTER_KEY=...          # from config/master.key
```

**Optional:**

```bash
SENTRY_DSN=...
SMTP_ADDRESS=...
SMTP_USERNAME=...
SMTP_PASSWORD=...
```

### Commands

```bash
# Staging
git push staging main
heroku run rails db:migrate -a <staging-app>
heroku run rails db:seed    -a <staging-app>
curl https://<staging-app>.herokuapp.com/healthz
```

### Heroku Config

* Dyno: **Eco** ($5) or **Basic** ($7)
* Postgres: **Mini** ($5, 10k rows)
* Backups: daily, 7-day retention (automatic)
* Logs: `heroku logs --tail -a <app>`

### Health Check Endpoint

```ruby
# GET /healthz (unauthenticated)
class HealthController < ApplicationController
  skip_before_action :verify_authenticity_token
  skip_before_action :authenticate_user!

  def check
    ActiveRecord::Base.connection.execute('SELECT 1')
    render json: { status: 'healthy', database: 'connected', timestamp: Time.current.utc.iso8601 }
  rescue => e
    render json: { status: 'unhealthy', error: e.message }, status: 503
  end
end
```

---

## Project-Specific Rules

### Business Rules

1. Workers with assignment history **cannot be deleted** — set `active=false`.
2. Every data modification **must** create an `ActivityLog` record.
3. MVP is **admin-only** (no worker/client portal).
4. Seed 3 admins: **Natalie, Madison, Sarah**.

### Status Workflows

* **Shifts:** `draft → published → assigned → completed`
* **Assignments:** `assigned → completed | no_show | cancelled`

### Activity Logging (Pattern)

```ruby
# app/models/concerns/auditable.rb
module Auditable
  extend ActiveSupport::Concern

  included do
    after_create :log_create
    after_update :log_update
    after_destroy :log_destroy
  end

  def log_create
    ActivityLog.create!(
      actor_user_id: Current.user&.id,
      entity_type: self.class.name,
      entity_id: id,
      action: 'created',
      after_json: attributes,
      created_at_utc: Time.current
    )
  end

  def log_update
    return unless saved_changes.any?
    ActivityLog.create!(
      actor_user_id: Current.user&.id,
      entity_type: self.class.name,
      entity_id: id,
      action: 'updated',
      before_json: saved_changes.transform_values(&:first),
      after_json: saved_changes.transform_values(&:last),
      created_at_utc: Time.current
    )
  end
end
```

---

## Generation Guidelines

1. Add friendly, actionable validation messages.
2. Use comments only for non-obvious business logic.
3. Consider nil/empty/boundary/concurrent cases.
4. Generate tests alongside core logic.
5. Prefer “Rails way” solutions; avoid over-engineering.
6. Eager load associations to avoid N+1s.

---

## Critical Reminders

* **21-day MVP** — hold the line on scope.
* **Rails 7 + Postgres** (not MySQL).
* **Heroku** hosting on GravyWork’s account.
* **UTC everywhere** (`*_utc` + TIMESTAMPTZ).
* **Advisory locks** on assignments.
* **Three** conflict rules only: overlap, capacity, cert expiration.
* **Soft deletes** for workers with history.