# Social Catering MVP - Cursor AI Rules
# Tailored to existing codebase (analyzed 2025-11-07)
# Ruby 3.4.5 | Rails 7.2.0 | React 18 | TypeScript 5 | PostgreSQL 14+ | Heroku

---

## ğŸ¯ Project Context

**Purpose:** Workforce scheduling tool for Social Catering (3 admins, ~30 workers, 100+ shifts/month)  
**Status:** MVP in production (Heroku staging + production)  
**Team:** Solo developer (Kishan) â†’ handoff to GravyWork team  
**Timeline:** 21-day MVP (feature-complete, now in maintenance/polish)  
**Budget:** $5,000 fixed price (avoid scope creep)

---

## ğŸ—ï¸ Core Principles (Non-Negotiable)

### 1. **DRY (Don't Repeat Yourself)**
- âŒ Never copy-paste code
- âœ… Extract to service, concern, or component
- âœ… Reuse existing patterns (ApplicationService, Auditable, etc.)

### 2. **SSOT (Single Source of Truth)**
- âœ… Cost calculations: `Assignment#total_pay` (model method)
- âœ… Activity logging: `Auditable` concern (not manual logs)
- âœ… Conflict detection: `CheckShiftConflicts` service (not inline)
- âœ… API responses: Presenters (not controller serialization)
- âœ… Constants: `config/constants.rb` (not magic strings)

### 3. **Fail Fast, Fail Loud**
- âœ… Raise exceptions immediately (don't return `nil`)
- âœ… Validate at database, model, and controller layers
- âœ… Use guard clauses (early returns)

---

## ğŸ“‚ File Organization (Existing Structure)

### Backend
app/ â”œâ”€â”€ controllers/api/v1/ # All API controllers â”‚ â””â”€â”€ base_controller.rb # render_success, render_error, render_validation_errors â”œâ”€â”€ models/ â”‚ â”œâ”€â”€ concerns/ â”‚ â”‚ â”œâ”€â”€ auditable.rb # Activity logging (SSOT) â”‚ â”‚ â”œâ”€â”€ hours_calculations.rb â”‚ â”‚ â””â”€â”€ pay_calculations.rb â”‚ â”œâ”€â”€ worker.rb â”‚ â”œâ”€â”€ shift.rb â”‚ â”œâ”€â”€ assignment.rb â”‚ â””â”€â”€ [15 other models] â”œâ”€â”€ services/ # Business logic (18 services) â”‚ â”œâ”€â”€ application_service.rb # Base class (success/failure) â”‚ â”œâ”€â”€ assign_worker_to_shift.rb â”‚ â”œâ”€â”€ check_shift_conflicts.rb â”‚ â”œâ”€â”€ search_workers.rb â”‚ â””â”€â”€ [15 other services] â”œâ”€â”€ presenters/ â”‚ â””â”€â”€ activity_log_presenter.rb â””â”€â”€ views/ # Minimal (React handles UI)

lib/tasks/ # Rake tasks only

Code

### Frontend
social-catering-ui/src/ â”œâ”€â”€ components/ â”‚ â”œâ”€â”€ common/ # Reusable UI (SSOT) â”‚ â”‚ â”œâ”€â”€ LoadingSpinner.tsx â”‚ â”‚ â”œâ”€â”€ Toast.tsx â”‚ â”‚ â”œâ”€â”€ Modal.tsx â”‚ â”‚ â””â”€â”€ EmptyState.tsx â”‚ â”œâ”€â”€ Dashboard/ â”‚ â”œâ”€â”€ Shifts/ â”‚ â”œâ”€â”€ Assignments/ â”‚ â””â”€â”€ [feature folders] â”œâ”€â”€ hooks/ â”‚ â”œâ”€â”€ useWorkers.ts â”‚ â”œâ”€â”€ useShifts.ts â”‚ â””â”€â”€ [custom hooks] â”œâ”€â”€ services/ â”‚ â”œâ”€â”€ workersApi.ts â”‚ â”œâ”€â”€ shiftsApi.ts â”‚ â””â”€â”€ [API services] â”œâ”€â”€ lib/ â”‚ â”œâ”€â”€ api.ts # Axios instance (SSOT) â”‚ â”œâ”€â”€ utils.ts # Helper functions â”‚ â””â”€â”€ normalize.ts â””â”€â”€ types/ â”œâ”€â”€ worker.ts â”œâ”€â”€ shift.ts â””â”€â”€ [TypeScript types]

Code

---

## ğŸ”§ Existing Patterns (Must Follow)

### 1. **Service Objects Pattern**

**Base Class:**
```ruby
# app/services/application_service.rb
class ApplicationService
  def self.call(*args, **kwargs)
    new(*args, **kwargs).call
  end

  def success(data = {})
    { success: true, data: data }
  end

  def failure(error, status: :unprocessable_entity)
    { success: false, error: error, status: status }
  end
end
Implementation Pattern:

Ruby
# âœ… CORRECT: Follow this exact pattern
class AssignWorkerToShift < ApplicationService
  def initialize(shift, worker, assigned_by)
    @shift = shift
    @worker = worker
    @assigned_by = assigned_by
  end

  def call
    # Set Current.user for Auditable concern
    Current.user = @assigned_by
    
    # Guard clauses (fail fast)
    raise ArgumentError, "Shift is required" if @shift.nil?
    raise ArgumentError, "Worker is required" if @worker.nil?
    
    # Business logic
    check_conflicts!
    create_assignment
    
    success(assignment: @assignment)
  rescue ConflictError => e
    failure(e.message, status: :conflict)
  rescue StandardError => e
    Rails.logger.error("Assignment failed: #{e.message}")
    Sentry.capture_exception(e) if defined?(Sentry)
    failure("Internal error: #{e.message}", status: :internal_server_error)
  end

  private

  def check_conflicts!
    conflicts = CheckShiftConflicts.call(@shift, @worker)
    raise ConflictError, format_conflicts(conflicts) if conflicts.any?
  end

  def create_assignment
    @assignment = Assignment.create!(
      shift: @shift,
      worker: @worker,
      assigned_by: @assigned_by,
      status: 'assigned',
      hourly_rate: @worker.hourly_rate
    )
  end
end

# âŒ WRONG: Don't mix patterns
class MyService
  def call
    if some_condition
      { success: true }  # â† Using hash
    else
      raise SomeError    # â† AND raising? Pick one!
    end
  end
end
Service Naming Convention:

AssignWorkerToShift (verb + object, no Service suffix)
CheckShiftConflicts (verb + object)
SearchWorkers (verb + object)
UpdateWorkerCertifications (verb + object)
2. Auditable Concern (Activity Logging)
Location: app/models/concerns/auditable.rb

Usage:

Ruby
# âœ… CORRECT: Just include the concern
class Worker < ApplicationRecord
  include Auditable  # Automatically logs create/update/destroy
end

# âŒ WRONG: Manual activity logs
class Worker < ApplicationRecord
  after_save do
    ActivityLog.create!(...)  # â† Don't! Use Auditable concern
  end
end
How to set actor:

Ruby
# In service or controller
Current.user = @assigned_by  # Auditable reads this
@worker.save  # Automatically logs with Current.user as actor
3. Controller Pattern
Base Controller:

Ruby
# app/controllers/api/v1/base_controller.rb
class Api::V1::BaseController < ApplicationController
  before_action :authenticate_user!
  
  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found
  rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity
  
  def render_success(data, status: :ok)
    render json: { success: true, data: data }, status: status
  end

  def render_error(error, status: :unprocessable_entity)
    render json: { success: false, error: error }, status: status
  end

  def render_validation_errors(record)
    render json: { success: false, errors: record.errors.full_messages }, status: :unprocessable_entity
  end
end
Implementation Pattern:

Ruby
# âœ… CORRECT: Use base controller methods
class Api::V1::WorkersController < Api::V1::BaseController
  def create
    @worker = Worker.new(worker_params)
    if @worker.save
      render_success(serialize_worker(@worker), status: :created)
    else
      render_validation_errors(@worker)
    end
  end

  private

  def worker_params
    params.require(:worker).permit(:first_name, :last_name, :phone, :email, :hourly_rate)
  end

  def serialize_worker(worker)
    # TODO: Extract to presenter/serializer
    {
      id: worker.id,
      first_name: worker.first_name,
      last_name: worker.last_name,
      full_name: worker.full_name,
      phone: worker.phone,
      email: worker.email,
      hourly_rate: worker.hourly_rate,
      active: worker.active,
      skills: worker.skills_json || []
    }
  end
end

# âŒ WRONG: Don't reinvent base methods
class SomeController < Api::V1::BaseController
  def create
    render json: { success: true, data: {} }  # â† Use render_success!
  end
end
4. Error Handling Standard
Pattern: Raise in services, catch in controllers

Ruby
# âœ… CORRECT: Service raises, controller catches
class AssignWorkerToShift < ApplicationService
  def call
    raise ConflictError, "Worker has overlapping shift" if conflicts.any?
    success(assignment: @assignment)
  rescue ConflictError => e
    failure(e.message, status: :conflict)
  end
end

class Api::V1::AssignmentsController < Api::V1::BaseController
  def create
    result = AssignWorkerToShift.call(shift, worker, current_user)
    if result[:success]
      render_success(result[:data][:assignment])
    else
      render_error(result[:error], status: result[:status])
    end
  end
end

# âŒ WRONG: Don't mix patterns
class SomeService
  def call
    return nil if error  # â† Don't return nil, raise!
  end
end
5. Frontend Component Pattern
Reusable Components (SSOT):

TSX
// âœ… CORRECT: Use existing components from common/
import { LoadingSpinner } from '@/components/common/LoadingSpinner';
import { Toast } from '@/components/common/Toast';
import { Modal } from '@/components/common/Modal';

// âŒ WRONG: Don't create duplicate components
// Don't create: components/MyLoadingSpinner.tsx
// Don't create: components/MyModal.tsx
Component Naming:

TSX
// âœ… CORRECT: PascalCase, descriptive
WorkerCard.tsx
ShiftList.tsx
AssignmentRow.tsx
ApprovalModal.tsx

// âŒ WRONG: Generic names, wrong case
Card.tsx           // Too generic
worker-card.tsx    // Wrong case
WorkerComponent.tsx // Redundant "Component"
Hook Naming:

TSX
// âœ… CORRECT: use prefix, descriptive
useWorkers.ts
useShifts.ts
useDebounce.ts
useConfirm.ts

// âŒ WRONG: Missing "use", unclear
workers.ts         // Missing "use"
useData.ts         // Too generic
6. TypeScript Type Safety
Pattern:

TSX
// âœ… CORRECT: Define types in types/ directory
// types/worker.ts
export interface Worker {
  id: number;
  first_name: string;
  last_name: string;
  full_name: string;
  phone: string;
  email?: string;
  hourly_rate: number;
  active: boolean;
  skills: string[];
}

// Use everywhere
function WorkerCard({ worker }: { worker: Worker }) {
  return <div>{worker.full_name}</div>;
}

// âŒ WRONG: Inline types, any
function WorkerCard({ worker }: { worker: any }) {  // â† Don't use any!
  return <div>{worker.name}</div>;
}
ğŸš¨ Anti-Patterns (Never Do)
Backend
âŒ Manual Activity Logs

Ruby
# DON'T DO THIS
ActivityLog.create!(entity: @worker, action: 'created')

# DO THIS
class Worker < ApplicationRecord
  include Auditable  # Handles it automatically
end
âŒ Duplicate Serialization

Ruby
# DON'T DO THIS in every controller
def serialize_worker(worker)
  { id: worker.id, name: worker.full_name }
end

# DO THIS: Extract to presenter
class WorkerPresenter
  def self.serialize(worker)
    # Single source of truth
  end
end
âŒ Inline Business Logic

Ruby
# DON'T DO THIS
class WorkersController
  def create
    @worker = Worker.new(worker_params)
    # 50 lines of validation, conflict checking, etc.
    if @worker.save
      # ...
    end
  end
end

# DO THIS: Extract to service
class WorkersController
  def create
    result = CreateWorker.call(worker_params, current_user)
    if result[:success]
      render_success(result[:data])
    else
      render_error(result[:error])
    end
  end
end
âŒ Magic Strings

Ruby
# DON'T DO THIS
if shift.status == 'assigned'  # â† Hard-coded string

# DO THIS: Use constants
if shift.status == Constants::SHIFT_STATUS_ASSIGNED
âŒ Hard Deletes (Workers with History)

Ruby
# DON'T DO THIS
@worker.destroy  # â† Worker has assignments!

# DO THIS
@worker.update!(active: false)  # Soft delete
Frontend
âŒ Duplicate Components

TSX
// DON'T CREATE: components/MyLoadingSpinner.tsx
// DON'T CREATE: components/ui/LoadingSpinner.tsx
// DON'T CREATE: components/Spinner.tsx

// USE EXISTING: components/common/LoadingSpinner.tsx
âŒ Inline API Calls

TSX
// DON'T DO THIS
function WorkerList() {
  const [workers, setWorkers] = useState([]);
  useEffect(() => {
    fetch('/api/v1/workers')  // â† Inline API call
      .then(res => res.json())
      .then(data => setWorkers(data));
  }, []);
}

// DO THIS: Use custom hook
function WorkerList() {
  const { workers, loading } = useWorkers();  // â† Reusable hook
}
âŒ Any Type

TSX
// DON'T DO THIS
function handleWorker(worker: any) {  // â† No type safety!
  console.log(worker.name);
}

// DO THIS
function handleWorker(worker: Worker) {
  console.log(worker.full_name);
}
ğŸ“ Code Quality Standards
1. Naming Conventions
Backend:

Ruby
# Services: VerbObject (no Service suffix)
AssignWorkerToShift        âœ…
CheckShiftConflicts        âœ…
CreateWorkerService        âŒ

# Concerns: Adjective
Auditable                  âœ…
HoursCalculations          âœ…
Loggable                   âŒ (use Auditable)

# Models: Noun
Worker, Shift, Assignment  âœ…

# Methods: verb_object
def calculate_total_pay    âœ…
def get_worker             âŒ (use find_worker)
Frontend:

TSX
// Components: PascalCase noun
WorkerCard                 âœ…
ShiftList                  âœ…
workerCard                 âŒ

// Hooks: camelCase with "use"
useWorkers                 âœ…
useDebounce                âœ…
workers                    âŒ

// Utils: camelCase verb
formatDate                 âœ…
normalizeWorker            âœ…
DateFormatter              âŒ
2. Function Length
Target: < 20 lines per method

Ruby
# âœ… GOOD: Short, focused
def check_conflicts!
  conflicts = CheckShiftConflicts.call(@shift, @worker)
  raise ConflictError, format_conflicts(conflicts) if conflicts.any?
end

# âŒ BAD: Too long (> 50 lines)
def assign_worker
  # 50+ lines of validation, checking, assigning...
  # Extract to smaller methods!
end
3. Error Messages (User-Friendly)
Ruby
# âœ… GOOD: Actionable, specific
"Worker Sarah Johnson has an overlapping shift on Nov 7 from 2:00 PM - 6:00 PM. Please choose a different worker or time."
"Shift capacity is full (5/5 workers assigned). Remove a worker or increase capacity."
"Food Handler certification expires Nov 15 (required for this shift). Update certification or choose another worker."

# âŒ BAD: Vague, technical
"Validation failed"
"Conflict detected"
"Error 500"
4. Guard Clauses (Preferred)
Ruby
# âœ… GOOD: Guard clauses (early exit)
def assign_worker
  return failure("Worker required") if worker.nil?
  return failure("Shift required") if shift.nil?
  return failure("Shift full") if shift.full?
  
  create_assignment
  success(assignment: @assignment)
end

# âŒ AVOID: Nested if/else
def assign_worker
  if worker
    if shift
      if !shift.full?
        create_assignment
      else
        failure("Full")
      end
    else
      failure("No shift")
    end
  else
    failure("No worker")
  end
end
ğŸ—‚ï¸ Database Conventions
1. UTC Datetimes (Enforced)
Ruby
# âœ… CORRECT: All datetime columns end with _utc
create_table :shifts do |t|
  t.timestamptz :start_time_utc, null: false
  t.timestamptz :end_time_utc, null: false
  t.timestamptz :created_at_utc
end

# âŒ WRONG: Timezone-naive
create_table :shifts do |t|
  t.timestamp :start_time      # â† Missing _utc suffix!
end
2. Foreign Keys (Explicit)
Ruby
# âœ… CORRECT: Explicit on_delete
add_foreign_key :assignments, :workers, on_delete: :restrict
add_foreign_key :assignments, :shifts, on_delete: :cascade

# âŒ WRONG: No on_delete specified
add_foreign_key :assignments, :workers  # Default behavior unclear
3. Indexing
Ruby
# âœ… CORRECT: Index all foreign keys
add_index :assignments, :worker_id
add_index :assignments, :shift_id

# âœ… CORRECT: Compound indexes for queries
add_index :shifts, [:start_time_utc, :status]

# âœ… CORRECT: GIN for JSONB
add_index :workers, :skills_json, using: :gin
ğŸ§ª Testing Standards
1. Test Location
Code
test/                        # Minitest (primary)
â”œâ”€â”€ models/
â”œâ”€â”€ services/
â””â”€â”€ controllers/

spec/                        # RSpec (secondary, being phased out)
Preference: Use Minitest for new tests (Rails default)

2. Test Structure
Ruby
# test/services/assign_worker_to_shift_test.rb
class AssignWorkerToShiftTest < ActiveSupport::TestCase
  setup do
    @worker = workers(:sarah)  # Fixture
    @shift = shifts(:morning_shift)
  end

  test "assigns worker successfully when no conflicts" do
    result = AssignWorkerToShift.call(@shift, @worker, users(:admin))
    
    assert result[:success]
    assert_equal @shift, result[:data][:assignment].shift
    assert_equal @worker, result[:data][:assignment].worker
  end

  test "fails when worker has overlapping shift" do
    # Create overlapping assignment
    Assignment.create!(
      worker: @worker,
      shift: shifts(:overlapping_shift),
      status: 'assigned'
    )
    
    result = AssignWorkerToShift.call(@shift, @worker, users(:admin))
    
    assert_not result[:success]
    assert_match /overlap/i, result[:error]
  end

  test "fails when shift is at capacity" do
    # Fill shift to capacity
    @shift.capacity.times do
      Assignment.create!(
        worker: workers(:available),
        shift: @shift,
        status: 'assigned'
      )
    end
    
    result = AssignWorkerToShift.call(@shift, @worker, users(:admin))
    
    assert_not result[:success]
    assert_match /capacity/i, result[:error]
  end
end
3. Test Coverage Requirements
Services: 100% (all branches, edge cases)
Models: 100% (validations, associations, methods)
Controllers: 80%+ (happy path + common errors)
ğŸ”’ Security Standards
1. Strong Params (Always)
Ruby
# âœ… CORRECT
def worker_params
  params.require(:worker).permit(:first_name, :last_name, :phone, :email, :hourly_rate)
end

# âŒ WRONG
def worker_params
  params[:worker]  # â† Mass assignment vulnerability!
end
2. SQL Injection Prevention
Ruby
# âœ… CORRECT: Parameterized
Worker.where("first_name ILIKE ?", "%#{query}%")

# âŒ WRONG: String interpolation
Worker.where("first_name ILIKE '%#{query}%'")  # â† SQL injection risk!
3. Authentication
Ruby
# âœ… CORRECT: All API endpoints require auth
class Api::V1::BaseController < ApplicationController
  before_action :authenticate_user!  # Devise
end

# âŒ WRONG: Unauthenticated endpoints
class SomeController < ApplicationController
  # No authentication!
end
ğŸ“Š Performance Guidelines
1. N+1 Prevention
Ruby
# âœ… CORRECT: Eager load
@shifts = Shift.includes(:assignments, :worker).all

# âŒ WRONG: N+1 query
@shifts = Shift.all
@shifts.each { |s| puts s.assignments.count }  # â† N+1!
2. Pagination (Always)
Ruby
# âœ… CORRECT: Use Kaminari
@workers = Worker.active.page(params[:page]).per(25)

# âŒ WRONG: Load all records
@workers = Worker.all  # â† Memory issue with large datasets!
ğŸš€ Deployment Standards
1. Environment Variables (Required)
bash
# Production
DATABASE_URL=postgres://...
SECRET_KEY_BASE=...
RAILS_ENV=production
RAILS_MASTER_KEY=...
SENTRY_DSN=...  # Error tracking
2. Health Check
Ruby
# GET /healthz (unauthenticated)
class HealthController < ApplicationController
  skip_before_action :verify_authenticity_token
  skip_before_action :authenticate_user!

  def check
    ActiveRecord::Base.connection.execute('SELECT 1')
    render json: {
      status: 'healthy',
      database: 'connected',
      timestamp: Time.current.utc.iso8601
    }
  rescue => e
    render json: {
      status: 'unhealthy',
      error: e.message
    }, status: 503
  end
end
ğŸ¯ MVP Scope (Prevent Creep)
âœ… In Scope
Worker CRUD + search
Shift CRUD + assignment
Conflict detection (3 rules only)
Activity logging
Approval workflow
Basic reports
âŒ Out of Scope
Worker self-service portal
SMS notifications
CSV import/export
Advanced analytics
Mobile app
Public API
Rule: Any new feature requires approval from Bobby/Rav + timeline adjustment

ğŸ“ Documentation Standards
1. Minimal Comments (Preferred)
Ruby
# âœ… GOOD: Only when non-obvious
# Calculate overtime for non-exempt workers
# Overtime = hours worked - 40 hours/week
def calculate_overtime(hours)
  [hours - 40, 0].max
end

# âŒ BAD: Obvious comments
# Set name to name parameter
self.name = name  # â† Adds no value
2. README Format
Setup instructions
Environment variables
Running tests
Deployment process
Known issues
ğŸ”„ Code Review Checklist
Before committing, verify:

 Follows existing patterns (ApplicationService, Auditable, etc.)
 No duplicate code (check for similar methods/components)
 Uses SSOT (calculations in models, not controllers)
 Has tests (at least happy path)
 No N+1 queries (use includes)
 Strong params used
 Error messages are user-friendly
 Guard clauses (early returns)
 UTC datetime columns end with _utc
 No any types in TypeScript
 Reuses existing components (no new LoadingSpinner!)
ğŸš¨ Critical Reminders
Service Pattern: Use ApplicationService base, return { success:, data:, error: }
Activity Logging: Use Auditable concern (not manual logs)
Serialization: Extract to presenters (not controller methods)
Component Reuse: Check components/common/ before creating new
UTC Everywhere: All datetime columns must end with _utc
Soft Deletes: Workers with assignments use active: false (not destroy)
Guard Clauses: Fail fast with early returns
Error Messages: User-friendly, actionable, specific
Constants: Use config/constants.rb (no magic strings)
Scope Control: No new features without approval
ğŸ“ Project-Specific Context
Main Models:

Worker (first_name, last_name, email, phone, skills_json, active, hourly_rate)
Shift (start_time_utc, end_time_utc, role_needed, capacity, status, pay_rate, event_id)
Assignment (worker_id, shift_id, status, hours_worked, hourly_rate, approved, approved_by_id)
Event (title, status, venue_id, total_shifts_count, assigned_shifts_count)
ActivityLog (actor_user_id, entity_type, entity_id, action, before_json, after_json)
Conflict Rules (Only 3):

Time overlap (start < existing.end AND end > existing.start)
Capacity (assigned_count < shift.capacity)
Certification expiration (cert.expires_at_utc >= shift.end_time_utc)
Tech Stack:

Ruby 3.4.5, Rails 7.2.0, PostgreSQL 14+
React 18, TypeScript 5, Tailwind CSS 3.4
Heroku (staging: sc-mvp-staging, production: sc-mvp-production)
Sentry (error tracking)
Remember: This is production code for professional use, not a prototype. Optimize for clarity, maintainability, and reliability.

Code

---

## âœ… What This `.cursorrules` File Does

### 1. **Enforces Your Existing Patterns**
- ApplicationService base class
- Auditable concern
- BaseController methods
- Component structure

### 2. **Prevents Specific Problems Found**
- âŒ No inconsistent error handling
- âŒ No duplicate serialization in controllers
- âŒ No duplicate frontend components
- âŒ No manual activity logs

### 3. **Maintains Code Quality**
- Guard clauses (early returns)
- User-friendly error messages
- SSOT for calculations
- Type safety (TypeScript)

### 4. **Scales Properly**
- Service objects for business logic
- Eager loading (no N+1)
- Indexing guidelines
- Pagination

---

## ğŸš€ How to Use

1. **Save this file** as `.cursorrules` in your project root (same level as `Gemfile`)

2. **Test it:**
   - Open Cursor
   - Ask: "Create a new service to bulk assign workers to shifts"
   - Cursor should follow the ApplicationService pattern

3. **Iterate:**
   - If Cursor generates bad code, add specific rules
   - Reference this file in prompts: "Follow the .cursorrules pattern"

---
